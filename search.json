[{"title":"about","url":"/2025/04/14/about/","content":"分类\n","categories":["test"],"tags":["about"]},{"title":"iptables防止ddos(cc)","url":"/2025/04/21/iptables%E9%98%B2%E6%AD%A2ddos-cc/","content":"\n基本上发行版都是自带的，轻量级，不需要额外下载Fail2Ban也可以但是需要额外下载\n\n如何配置使用iptables -I INPUT -p tcp --dport 80 -m state --state NEW -m recent --set参数    作用-I INPUT    将规则插入到 INPUT 链的最前面-p tcp --dport 80    匹配目标端口为 80 的 TCP 流量-m state --state NEW    仅匹配 新建连接（如 TCP 的 SYN 包）-m recent --set    将来源 IP 记录到 recent 模块的默认列表（/proc/net/xt_recent/DEFAULT）iptables -I INPUT -p tcp --dport 80 -m state --state NEW -m recent --update --seconds 60 --hitcount 100 -j DROP参数    作用-m recent --update --seconds 60 --hitcount 100    检查 IP 在 60 秒内是否发起超过 100 次新连接-j DROP    若超限，直接丢弃数据包\n\n效果图，到指定次数自动丢弃数据包，端口不通，到达指定时间自动恢复\n经过测试 –hitcount 大于20 会报错\n解决办法echo options xt_recent ip_pkt_list_tot=200 &gt; /etc/modprobe.d/xt.confmodprobe -r xt_recent &amp;&amp; modprobe xt_recent 重新加载查看 lsmod |grep xt  ；cat /sys/module/xt_recent/parameters/ip_pkt_list_tot 对应 xt.conf\n额外补充若其他规则也使用 recent 默认列表，可能导致误判，可以通过–name 指定名称分类\niptables -I INPUT -p tcp –dport 80 -m state –state NEW -m recent –set –name HTTP_CC\niptables -I INPUT -p tcp –dport 80 -m state –state NEW -m recent –update –seconds 60 –hitcount 200 –name HTTP_CC -j DROP\n则 &#x2F;proc&#x2F;net&#x2F;xt_recent&#x2F;HTTP_CC 叫 HTTP_CC\n","categories":["linux"]},{"title":"miniconda3","url":"/2025/04/21/miniconda3/","content":"\nconda是一个包和环境管理工具，用于创建、管理和切换Python的虚拟环境\n\n安装mkdir -p ~/miniconda3wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.shbash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3rm ~/miniconda3/miniconda.shsource ~/miniconda3/bin/activate\n使用1. conda --version #查看conda版本，验证是否安装2. conda update conda #更新至最新版本，也会更新其它相关包3. conda update --all #更新所有包4. conda update package_name #更新指定的包5. conda create -n env_name package_name #创建名为env_name的新环境，并在该环境下安装名为package_name 的包，可以指定新环境的版本号，例如：conda create -n python2 python=python2.7 numpy pandas，创建了python2环境，python版本为2.7，同时还安装了numpy pandas包6. source activate env_name #切换至env_name环境7. source deactivate #退出环境8. conda info -e #显示所有已经创建的环境9. conda create --name new_env_name --clone old_env_name #复制old_env_name为new_env_name10. conda remove --name env_name –all #删除环境11. conda list #查看所有已经安装的包12. conda install package_name #在当前环境中安装包13. conda install --name env_name package_name #在指定环境中安装包14. conda remove -- name env_name package #删除指定环境中的包15. conda remove package #删除当前环境中的包16. conda env remove -n env_name #采用第10条的方法删除环境失败时，可采用这种方法\n\n\n\n两个环境，一个有request一个没有，隔离作用\n镜像源# 查看镜像源conda config --show-sources# 添加镜像源conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main# 从镜像源中安装包时显示来源conda config --set show_channel_urls yes# 删除镜像源conda config --remove channels https://XXX# 删除配置的镜像源，使用默认镜像源conda config --remove-key channels\n\n打包运行环境pip install conda-packconda pack -n my_env_name -o out_name.tar.gztar -zxvf 2.7.tar.gz -C 2.7conda info -esource activate my_env_name\n\n","categories":["python"]},{"title":"openvpn","url":"/2025/04/21/openvpn/","content":"安装git clone https://github.com/likaiyuan00/openvpn-install.gitcd openvpn-install &amp;&amp; bash openvpn-install.sh#systemctl start openvpn@client.service 启动的账号密码  auth-user-pass 控制客户端密码验证echo &quot;test test@123&quot; &gt;  /etc/openvpn/userfile.sh\n\n配置文件字段解读server端在#openvpn服务端的监听地址local 0.0.0.0#openvpn服务端的监听端口（默认1194）port 1115#使用的协议，tcp/udpproto tcp#使用三层路由ip隧道（tun），还是二层以太网隧道（tap），一般使用tundev tun#ca证书、服务端证书、服务端秘钥和秘钥交换文件ca /etc/openvpn/server/ca.crtcert /etc/openvpn/server/server.crtkey /etc/openvpn/server/server.keydh /etc/openvpn/server/dh.pem#vpn服务端为自己和客户端分配的ip地址池。#服务端自己获取网段的第一个地址（此处是10.8.0.1），后为客户端分配其他的可用地址。以后客户端就可以和10.8.0.1进行通信。注意：以下网段地址不要和已有网段冲突或重复server 10.8.0.0  255.255.255.0#使用一个文件记录已分配虚拟ip的客户端和虚拟ip的对应关系。以后openvpn重启时，将可以按照此文件继续为对应的客户端分配此前相同的ip（自动续借ip）ifconfig-pool-persist ipp.txt#使用tap模式的时候考虑此选项server-bridge XXXXXX#vpn服务端向客户端推送vpn服务端内网网段的路由配置，以便让客户端能够找到服务端的内网。多条路由写多个push指令push &quot;route 10.0.10.0  255.255.255.0&quot;push &quot;route 192.168.10.0 255.255.255.0&quot;  #允许客户端访问的内网网段#让vpn客户端之间可以通信。默认情况客户端只能服务端进行通信#默认此项是注释的，客户端之间不能相互通信client-to-client#允许多个客户端使用同一个vpn账号连接服务端#默认是注释的，不支持多个客户端登录一个账号duplicate-cn#每10秒ping一次，120秒后没收到ping就说明对方挂了keepalive 10 120#加强认证方式，防攻击。如果配置文件中启用此项（默认是启用的），需要执行openvpn --genkey --secret ta.key，并把ta.key放到/etc/openvpn/server/目录，服务端第二个参数为0；同时客户端也要有此文件，且client.conf中此指令的第二个参数需要为1tls-auth /etc/openvpn/server/ta.key 0#选择一个密码。如果在服务器上使用了cipher选项，那么也必须在这里指定它。注意，v2.4客户端/服务端将在tls模式下自动协商AES-256-GCMcipher AES-256-CBC#openvpn 2.4版本的vpn才能设置此选项。表示服务端启用lz4的压缩功能 ，传输数据给客户端时会压缩数据包。Push后在客户端也配置启用lz4的压缩功能，向服务端发数据时也会压缩。如果是2.4版本以下的老版本，则使用用comp-lzo指令compress lz4-v2push &quot;compress lz4-v2&quot;#启用lzo数据压缩格式，此指令用于低于2.4版本的老版本，且如果服务端配置了该指令，客户端也必须要配置comp-lzo#并发客户端的连接数max-clients 1000#通过ping得知超时时，当重启vpn后将使用同一个秘钥文件以及保持tun连接状态persist-keypersist-tun#在文件中输出当前的连接信息，每分钟截断并重写一次该文件status openvpn-status.log#log指令表示每次启动vpn时覆盖式记录到指定日志文件中#log-append则表示每次启动vpn时追加式的记录到指定日志中#但两者只能选其一，或者不选时记录到rsyslog中log  /var/log/openvpn.loglog-append  /var/log/openvpn.log#日志记录的详细级别verb 3#当服务器重新启动时，通知客户端，以便它可以自动重新连接。仅在UDP协议是可用explicit-exit-notify 1#沉默的重复信息。最多20条相同消息类别的连续消息将输出到日志mute 20\nclient#标识这是个客户端client#使用的协议，tcp/udp，服务端是什么客户端就是什么proto tcp#使用三层路由ip隧道（tun），还是二层以太网隧道（tap），服务端是什么客户端就是什么dev tun#服务端的地址和端口remote 10.0.0.190 1194#一直尝试解析OpenVPN服务器的主机名resolv-retry infinite#大多数客户机不需要绑定到特定的本地端口号nobind#初始化后的降级特权(仅非windows)user nobodygroup nobody#尝试在重新启动时保留某些状态persist-keypersist-tun#ca证书、客户端证书、客户端密钥#如果它们和client.conf或client.ovpn在同一个目录下则可以不写绝对路径，否则需要写绝对路径调用ca ca.crtcert client.crtkey client.key#通过检查certicate是否具有正确的密钥使用设置来验证服务器证书。remote-cert-tls server#加强认证方式，防攻击。服务端有配置，则客户端必须有tls-auth ta.key 1#选择一个密码。如果在服务器上使用了cipher选项，那么您也必须在这里指定它。注意，v2.4客户端/服务器将在TLS模式下自动协商AES-256-GCM。cipher AES-256-CBC# 服务端用的什么，客户端就用的什么#表示客户端启用lz4的压缩功能，传输数据给客户端时会压缩数据包comp-lzo# 日志级别verb 3#沉默的重复信息。最多20条相同消息类别的连续消息将输出到日志mute 20\n\n如何直连openvpn服务端其他局域网服务器\n客户端（10.8.0.10） ping (服务端)172.16.1.7 正常 ping (服务端其他内网机器)172.16.1.8失败\n\n\n第一种方法 配置路由route add -net 10.8.0.0 netmask 255.255.255.0 gw 172.16.1.710.8.0.0  客户端IP172.16.1.7 openvpn 服务端IP\n\n\n\n\n\n\n\n第二种方法使用snat转发 iptables -t nat -A POSTROUTING -d 10.8.0.0&#x2F;24 -o eth0 -j MASQUERADEiptables -A FORWARD -s 10.8.0.0 -j ACCEPT\n\n\n\n额外服务端route 192.168.0.0 255.255.0.0   指令作用是在服务端加一条路由，网关是客户端ip\n服务端只能ping通客户端的tun0的ip，内网ip不行，即使加了路由也不行\n客户端push “route 192.168.10.0 255.255.255.0”作用是在客户端多加一条路由。网关是服务端的tun0IP（也就是server 指令配置分配的地址池）\n","categories":["linux"]},{"title":"prometheus","url":"/2025/04/18/prometheus/","content":"https://github.com/likaiyuan00/k8s-prometheus.git\nk8s-prometheus部署kubernetes_sd_configs配置文件只采集了\n\n1 prometheus*  prometheus-server2 container*   kubelet 的10250端口  &#x2F;metrics&#x2F;cadvisor3 node*    node_exporter4 apiserver*  apiserver 6443 端口 &#x2F;metrics5 kube*  kube-state-metrics组件 8080端口 &#x2F;metrics6 coredns*  kubernetes-pods 自动发现 pod需要配置 prometheus.io&#x2F;scrape: “true” 不然抓取不到 默认flaseprometheus.io&#x2F;path: “&#x2F;metrics”   # 指标路径（默认 &#x2F;metrics 可不写）7 kubelet*  apiserver代理端点 &#x2F;api&#x2F;v1&#x2F;nodes&#x2F;&lt;node-name&gt;&#x2F;proxy&#x2F;metrics其他有需要的可以自行配置\n\n导入镜像，执行yml文件即可\nprometheus效果图\ngrafana效果图\nkubelet 组件 kubelet 三个指标 &#x2F;metrics&#x2F;probes（探针） &#x2F;metrics&#x2F;cadvisor（pod） &#x2F;metrics（node）\n对应apiserver的 &#x2F;api&#x2F;v1&#x2F;nodes&#x2F;${node-name}&#x2F;proxy&#x2F;${url};一般为了减少apiserver的负载不建议使用这种方式 **\n直接访问会报401没有权限\n需要先获取token，上面文件执行完会有一个prometheus用户\npod内token路径为 &#x2F;var&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount&#x2F;token\n通过token再去访问发现就正常了\n/metricscurl -k -sS  -H &quot;Authorization: Bearer $TOKEN&quot;  https://127.0.0.1:6443/api/v1/nodes/master/proxy/metricscurl -k -sS  -H &quot;Authorization: Bearer $TOKEN&quot;  https://127.0.0.1:10250/metrics\n\n对应kubelet*开头\n/metrics/probes（探针）curl -k -sS  -H &quot;Authorization: Bearer $TOKEN&quot;  https://127.0.0.1:6443/api/v1/nodes/master/proxy/metrics/probescurl -k -sS  -H &quot;Authorization: Bearer $TOKEN&quot;  https://127.0.0.1:10250/metrics/probes\n\n/metrics/cadvisor（pod）curl -k -sS  -H &quot;Authorization: Bearer $TOKEN&quot;  https://127.0.0.1:6443/api/v1/nodes/master/proxy/metrics/cadvisorcurl -k -sS  -H &quot;Authorization: Bearer $TOKEN&quot;  https://127.0.0.1:10250/metrics/cadvisor\n\n对应container*开头，容器指标\nnode_exporter端口暴露到节点了就不需要token了\nnode*开头，节点指标\nkube-state-metrics集群应用状态监控比较重要的一个需要单独安装使用containerPort: 8080 暴露到节点了不需要token\nkube*开头\napiserver主要是监控apiserver的qps,查询成功率失败率等信息\napiserver*开头\nkubernetes-pods 自动发现如果元数据内设置true，该pod才可以被抓取，默认false\n以coredns为例\n以coredns*开头\n这个自动发现还可以配置自身业务的监控，只有保证开启抓取，和符合prometheus抓取规范就可以，如果开启了prometheus.io&#x2F;scrape 但是pod并没有提供数据指标的能力就会直接报错，如图404\n比如现在我想加一个grafana的数据，只需要添加对应元数据就可以了\nprometheus就自动发现了pod的ip\ngrafana*开头\n","categories":["prometheus"],"tags":["prometheus"]}]